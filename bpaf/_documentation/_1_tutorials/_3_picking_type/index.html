<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content=" "><title>bpaf::_documentation::_1_tutorials::_3_picking_type - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="bpaf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../bpaf/index.html">bpaf</a><span class="version">0.9.15</span></h2></div><h2 class="location"><a href="#">Module _3_picking_type</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In bpaf::_documentation::_1_tutorials</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">bpaf</a>::<wbr><a href="../../index.html">_documentation</a>::<wbr><a href="../index.html">_1_tutorials</a>::<wbr><a class="mod" href="#">_3_picking_type</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../../src/bpaf/_documentation.rs.html#1874">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p> </p>
<table width='100%' cellspacing='0' style='border: hidden;'><tr>
  <td style='width: 33%; text-align: left;'>
<p><a href="../_2_derive_api/index.html" title="mod bpaf::_documentation::_1_tutorials::_2_derive_api">← Derive API tutorial</a></p>
  </td>
  <td style='width: 34%; text-align: center;'>
<p><a href="../index.html" title="mod bpaf::_documentation::_1_tutorials">↑ Tutorials ↑</a></p>
  </td>
  <td style='width: 33%; text-align: right;'>
  </td>
</tr></table>
<h5 id="designing-a-good-datatype"><a class="doc-anchor" href="#designing-a-good-datatype">§</a>Designing a good datatype</h5>
<p>bpaf allows you to reduce the size of legal values to valid ones</p>
<p>Parsing usually starts with deciding what kind of data your application wants to get from the user.
You should try to take advantage of the Rust type system, try to represent the result such that more
validation can be done during parsing.</p>
<p>Data types can represent a set of <em>legal</em> states - for example, for u8 this is all the numbers
from 0 to 255, while your app logic may only operate correctly only on some set of <em>valid</em>
states: if this u8 represents a fill ratio for something in percents - only valid numbers are
from 0 to 100. You can try to narrow down the set of legal states to valid states with <a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">newtype
pattern</a>. This newtype will
indicate through the type when you’ve already done validation. For the fill ratio example you can
implement a newtype along with <code>FromStr</code> implementation to get validation for free during
parsing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone, Copy)]
</span><span class="kw">pub struct </span>Ratio(u8);
 
<span class="kw">impl </span>FromStr <span class="kw">for </span>Ratio {
    <span class="kw">type </span><span class="prelude-val">Err </span>= <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str;
 
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="kw">match </span>s.parse() {
            <span class="prelude-val">Ok</span>(n) <span class="kw">if </span>n &lt;= <span class="number">100 </span>=&gt; <span class="prelude-val">Ok</span>(Ratio(n)),
            <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(<span class="string">"Invalid fill ratio"</span>)
        }
    }
}
 
<span class="attr">#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
</span><span class="kw">struct </span>Options {
    <span class="doccomment">/// Fill ratio
    </span>ratio: Ratio
}
 
<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run());
}</code></pre></div>
<p>Try using enums instead of structs for mutually exclusive options:</p>
<div class="example-wrap"><pre class="language-no_check"><code>/// Good format selection
#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
enum OutputFormat {
    Intel,
    Att,
    Llvm
}
 
fn main() {
    let format = output_format().run();
 
    // `rustc` ensures you handle each case, parser won&#39;t try to consume
    // combinations of flags it can&#39;t represent. For example it won&#39;t accept
    // both `--intel` and `--att` at once
    // (unless it can collect multiple of them in a vector)
    match format {
        OutputFormat::Intel =&gt; ...,
        OutputFormat::Att =&gt; ...,
        OutputFormat::Llvm =&gt; ...,
    }
}
</code></pre></div>
<p>While it’s easy to see how flags like <code>--intel</code> and <code>--att</code> maps to each of those bools,
consuming inside your app is more fragile</p>
<div class="example-wrap"><pre class="language-no_check"><code>/// Bad format selection
#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
struct OutputFormat {
    intel: bool,
    att: bool,
    llvm: bool,
}
 
fn main() {
    let format = output_format().run();
    // what happens when none matches? Or all of them?
    // What happens when you add a new output format?
    if format.intel {
        ...
    } else if format.att {
        ...
    } else if format.llvm {
        ...
    } else {
        // can this branch be reached?
    }
}
</code></pre></div>
<p>Mutually exclusive things are not limited to just flags. For example if your program can take
input from several different sources such as file, database or interactive input it’s a good
idea to use enum as well:</p>
<div class="example-wrap"><pre class="language-no_check"><code>/// Good input selection
#[derive(Debug, Clone, Bpaf)]
enum Input {
    File {
        filepath: PathBuf,
    }
    Database {
        user: String,
        password: String.
    }
    Interactive,
}
</code></pre></div>
<p>If your codebase uses newtype pattern - it’s a good idea to use it starting from the command
options:</p>
<div class="example-wrap"><pre class="language-no_check"><code>#[derive(Debug, Clone, Bpaf)]
struct Options {
    // better than taking a String and parsing internally
    date: NaiveDate,
    // f64 might work too, but you can start from some basic sanity checks
    speed: Speed
}
</code></pre></div><h2 id="more-reading"><a class="doc-anchor" href="#more-reading">§</a>More reading</h2>
<ul>
<li><a href="https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/</a></li>
<li><a href="https://geeklaunch.io/blog/make-invalid-states-unrepresentable/">https://geeklaunch.io/blog/make-invalid-states-unrepresentable/</a></li>
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</a></li>
<li><a href="https://khalilstemmler.com/articles/typescript-domain-driven-design/make-illegal-states-unrepresentable/">https://khalilstemmler.com/articles/typescript-domain-driven-design/make-illegal-states-unrepresentable/</a></li>
</ul>
<p> </p>
<table width='100%' cellspacing='0' style='border: hidden;'><tr>
  <td style='width: 33%; text-align: left;'>
<p><a href="../_2_derive_api/index.html" title="mod bpaf::_documentation::_1_tutorials::_2_derive_api">← Derive API tutorial</a></p>
  </td>
  <td style='width: 34%; text-align: center;'>
<p><a href="../index.html" title="mod bpaf::_documentation::_1_tutorials">↑ Tutorials ↑</a></p>
  </td>
  <td style='width: 33%; text-align: right;'>
  </td>
</tr></table>
</div></details></section></div></main></body></html>