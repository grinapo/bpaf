<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Parse a positional argument"><title>positional in bpaf - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bpaf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bpaf/index.html">bpaf</a><span class="version">0.9.15</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">bpaf</a>::<wbr><a class="fn" href="#">positional</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/bpaf/lib.rs.html#1401-1403">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub fn positional&lt;T&gt;(metavar: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="parsers/struct.ParsePositional.html" title="struct bpaf::parsers::ParsePositional">ParsePositional</a>&lt;T&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Parse a positional argument</p>
<p>For named flags and arguments ordering generally doesn’t matter: most programs would
understand <code>-O2 -v</code> the same way as <code>-v -O2</code>, but for positional items order matters: in *nix
<code>cat hello world</code> and <code>cat world hello</code> would display contents of the same two files but in
a different order.</p>
<p>When using combinatoric API you can specify the type with turbofish, for parsing types
that don’t implement <a href="https://doc.rust-lang.org/1.81.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a> you can use consume a <code>String</code>/<code>OsString</code> first and parse
it by hand.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>parse_pos() -&gt; <span class="kw">impl </span>Parser&lt;usize&gt; {
    positional::&lt;usize&gt;(<span class="string">"POS"</span>)
}</code></pre></div>
<h2 id="important-restriction"><a class="doc-anchor" href="#important-restriction">§</a>Important restriction</h2>
<p>To parse positional arguments from a command line you should place parsers for all your
named values before parsers for positional items and commands. In derive API fields parsed as
positional items or commands should be at the end of your <code>struct</code>/<code>enum</code>. The same rule applies
to parsers with positional fields or commands inside: such parsers should go to the end as well.</p>
<p>Use <a href="struct.OptionParser.html#method.check_invariants" title="method bpaf::OptionParser::check_invariants"><code>check_invariants</code></a> in your test to ensure correctness.</p>
<p>For example for non-positional <code>non_pos</code> and positional <code>pos</code> parsers</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>valid = <span class="macro">construct!</span>(non_pos(), pos());
<span class="kw">let </span>invalid = <span class="macro">construct!</span>(pos(), non_pos());</code></pre></div>
<p><strong><code>bpaf</code> panics during help generation unless this restriction holds</strong></p>
<p>Without using <code>--</code> <code>bpaf</code> would only accept items that don’t start with <code>-</code> as positional, you
can use <a href="fn.any.html" title="fn bpaf::any"><code>any</code></a> to work around this restriction.</p>
<p>By default <code>bpaf</code> accepts positional items with or without <code>--</code> where values permit, you can
further restrict the parser to accept positional items only on the right side of <code>--</code> using
<a href="parsers/struct.ParsePositional.html#method.strict" title="method bpaf::parsers::ParsePositional::strict"><code>strict</code></a>.</p>
<details><summary>Combinatoric example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>Options {
    verbose: bool,
    crate_name: String,
    feature_name: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">pub fn </span>options() -&gt; OptionParser&lt;Options&gt; {
    <span class="kw">let </span>verbose = short(<span class="string">'v'</span>)
        .long(<span class="string">"verbose"</span>)
        .help(<span class="string">"Display detailed information"</span>)
        .switch();

    <span class="kw">let </span>crate_name = positional(<span class="string">"CRATE"</span>).help(<span class="string">"Crate name to use"</span>);

    <span class="kw">let </span>feature_name = positional(<span class="string">"FEATURE"</span>)
        .help(<span class="string">"Display information about this feature"</span>)
        .optional();

    <span class="macro">construct!</span>(Options {
        verbose,
        <span class="comment">// You must place positional items and commands after
        // all other parsers
        </span>crate_name,
        feature_name
    })
    .to_options()
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Derive example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
</span><span class="kw">pub struct </span>Options {
    <span class="doccomment">/// Display detailed information
    </span><span class="attr">#[bpaf(short, long)]
    </span>verbose: bool,

    <span class="comment">// You must place positional items and commands after
    // all other parsers
    </span><span class="attr">#[bpaf(positional(<span class="string">"CRATE"</span>))]
    </span><span class="doccomment">/// Crate name to use
    </span>crate_name: String,

    <span class="attr">#[bpaf(positional(<span class="string">"FEATURE"</span>))]
    </span><span class="doccomment">/// Display information about this feature
    </span>feature_name: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Output</summary>
<p>Positional items show up in a separate group of arguments if they contain a help message,
otherwise they will show up only in <strong>Usage</strong> part.</p>
<div class='bpaf-doc'>
$ app --help<br>
<p><b>Usage</b>: <tt><b>app</b></tt> [<tt><b>-v</b></tt>] <tt><i>CRATE</i></tt> [<tt><i>FEATURE</i></tt>]</p><p><div>
<b>Available positional items:</b></div><dl><dt><tt><i>CRATE</i></tt></dt>
<dd>Crate name to use</dd>
<dt><tt><i>FEATURE</i></tt></dt>
<dd>Display information about this feature</dd>
</dl>
</p><p><div>
<b>Available options:</b></div><dl><dt><tt><b>-v</b></tt>, <tt><b>--verbose</b></tt></dt>
<dd>Display detailed information</dd>
<dt><tt><b>-h</b></tt>, <tt><b>--help</b></tt></dt>
<dd>Prints help information</dd>
</dl>
</p>
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<p>You can mix positional items with regular items</p>
<div class='bpaf-doc'>
$ app --verbose bpaf<br>
Options { verbose: true, crate_name: "bpaf", feature_name: None }
</div>
<p>And since <code>bpaf</code> API expects to have non positional items consumed before positional ones - you
can use them in a different order. In this example <code>bpaf</code> corresponds to a <code>crate_name</code> field and
<code>--verbose</code> – to <code>verbose</code>.</p>
<div class='bpaf-doc'>
$ app bpaf --verbose<br>
Options { verbose: true, crate_name: "bpaf", feature_name: None }
</div>
<p>In previous examples optional field <code>feature</code> was missing, this one contains it.</p>
<div class='bpaf-doc'>
$ app bpaf autocomplete<br>
Options { verbose: false, crate_name: "bpaf", feature_name: Some("autocomplete") }
</div>
<p>Users can use <code>--</code> to tell <code>bpaf</code> to treat remaining items as positionals - this might be
required to handle unusual items.</p>
<div class='bpaf-doc'>
$ app bpaf -- --verbose<br>
Options { verbose: false, crate_name: "bpaf", feature_name: Some("--verbose") }
</div>
<div class='bpaf-doc'>
$ app -- bpaf --verbose<br>
Options { verbose: false, crate_name: "bpaf", feature_name: Some("--verbose") }
</div>
<p>Without using <code>--</code> <code>bpaf</code> would only accept items that don’t start with <code>-</code> as positional.</p>
<div class='bpaf-doc'>
$ app --detailed<br>
<b>Error:</b> expected <tt><i>CRATE</i></tt>, got <b>--detailed</b>. Pass <tt><b>--help</b></tt> for usage information
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<div class='bpaf-doc'>
$ app --verbose<br>
<b>Error:</b> expected <tt><i>CRATE</i></tt>, pass <tt><b>--help</b></tt> for usage information
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<p>You can use <a href="fn.any.html" title="fn bpaf::any"><code>any</code></a> to work around this restriction.</p>
</details></div></details></section></div></main></body></html>