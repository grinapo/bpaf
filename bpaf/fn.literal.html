<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A specialized version of `any` that consumes an arbitrary string"><title>literal in bpaf - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bpaf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bpaf/index.html">bpaf</a><span class="version">0.9.15</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">bpaf</a>::<wbr><a class="fn" href="#">literal</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/bpaf/lib.rs.html#1490-1493">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub fn literal(val: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="parsers/struct.ParseAny.html" title="struct bpaf::parsers::ParseAny">ParseAny</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A specialized version of <a href="fn.any.html" title="fn bpaf::any"><code>any</code></a> that consumes an arbitrary string</p>
<p>By default <code>literal</code> behaves similarly to <a href="fn.positional.html" title="fn bpaf::positional"><code>positional</code></a> so you should be using it near the
rightmost end of the consumer struct and it will only try to parse the first unconsumed
item on the command line. It is possible to lift this restriction by calling
<a href="parsers/struct.ParseAny.html#method.anywhere" title="method bpaf::parsers::ParseAny::anywhere"><code>anywhere</code></a> on the parser.</p>
<details><summary>Combinatoric example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>Options {
    block_size: usize,
    count: usize,
    output_file: String,
    turbo: bool,
}

<span class="doccomment">/// Parses a string that starts with `name`, returns the suffix parsed in a usual way
</span><span class="kw">fn </span>tag&lt;T&gt;(name: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str, meta: <span class="kw-2">&amp;</span>str, help: <span class="kw">impl </span>Into&lt;Doc&gt;) -&gt; <span class="kw">impl </span>Parser&lt;T&gt;
<span class="kw">where
    </span>T: FromStr,
    &lt;T <span class="kw">as </span>FromStr&gt;::Err: std::fmt::Display,
{
    <span class="comment">// closure inside checks if command line argument starts with a given name
    // and if it is - it accepts it, otherwise it behaves like it never saw it
    // it is possible to parse OsString here and strip the prefix with
    // `os_str_bytes` or a similar crate
    </span>any(<span class="string">""</span>, <span class="kw">move </span>|s: String| <span class="prelude-val">Some</span>(s.strip_prefix(name)<span class="question-mark">?</span>.to_owned()))
        <span class="comment">// this defines custom metavar for the help message
        // so it looks like something it designed to parse
        </span>.metavar(<span class="kw-2">&amp;</span>[(name, Style::Literal), (meta, Style::Metavar)][..])
        .help(help)
        <span class="comment">// this makes it so tag parser tries to read all (unconsumed by earlier parsers)
        // item on a command line instead of trying and failing on the first one
        </span>.anywhere()
        <span class="comment">// At this point parser produces `String` while consumer might expect some other
        // type. [`parse`](Parser::parse) handles that
        </span>.parse(|s| s.parse())
}

<span class="kw">pub fn </span>options() -&gt; OptionParser&lt;Options&gt; {
    <span class="kw">let </span>block_size = tag(<span class="string">"bs="</span>, <span class="string">"BLOCK"</span>, <span class="string">"How many bytes to read at once"</span>)
        .fallback(<span class="number">1024</span>)
        .display_fallback();
    <span class="kw">let </span>count = tag(<span class="string">"count="</span>, <span class="string">"NUM"</span>, <span class="string">"How many blocks to read"</span>).fallback(<span class="number">1</span>);
    <span class="kw">let </span>output_file = tag(<span class="string">"of="</span>, <span class="string">"FILE"</span>, <span class="string">"Save results into this file"</span>);

    <span class="comment">// this consumes literal value of "+turbo" locate and produces `bool`
    </span><span class="kw">let </span>turbo = literal(<span class="string">"+turbo"</span>)
        .help(<span class="string">"Engage turbo mode!"</span>)
        .anywhere()
        .map(|<span class="kw">_</span>| <span class="bool-val">true</span>)
        .fallback(<span class="bool-val">false</span>);

    <span class="macro">construct!</span>(Options {
        block_size,
        count,
        output_file,
        turbo
    })
    .to_options()
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Derive example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This example is still technically derive API, but derive is limited to gluing
// things together and keeping macro complexity under control.
</span><span class="attr">#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
</span><span class="kw">pub struct </span>Options {
    <span class="comment">// `external` here and below derives name from the field name, looking for
    // functions called `block_size`, `count`, etc that produce parsers of
    // the right type.
    // A different way would be to write down the name explicitly:
    // #[bpaf(external(block_size), fallback(1024), display_fallback)]
    </span><span class="attr">#[bpaf(external, fallback(<span class="number">1024</span>), display_fallback)]
    </span>block_size: usize,
    <span class="attr">#[bpaf(external, fallback(<span class="number">1</span>))]
    </span>count: usize,
    <span class="attr">#[bpaf(external)]
    </span>output_file: String,
    <span class="attr">#[bpaf(external)]
    </span>turbo: bool,
}

<span class="kw">fn </span>block_size() -&gt; <span class="kw">impl </span>Parser&lt;usize&gt; {
    tag(<span class="string">"bs="</span>, <span class="string">"BLOCK"</span>, <span class="string">"How many bytes to read at once"</span>)
}

<span class="kw">fn </span>count() -&gt; <span class="kw">impl </span>Parser&lt;usize&gt; {
    tag(<span class="string">"count="</span>, <span class="string">"NUM"</span>, <span class="string">"How many blocks to read"</span>)
}

<span class="kw">fn </span>output_file() -&gt; <span class="kw">impl </span>Parser&lt;String&gt; {
    tag(<span class="string">"of="</span>, <span class="string">"FILE"</span>, <span class="string">"Save results into this file"</span>)
}

<span class="kw">fn </span>turbo() -&gt; <span class="kw">impl </span>Parser&lt;bool&gt; {
    literal(<span class="string">"+turbo"</span>)
        .help(<span class="string">"Engage turbo mode!"</span>)
        .anywhere()
        .map(|<span class="kw">_</span>| <span class="bool-val">true</span>)
        .fallback(<span class="bool-val">false</span>)
}

<span class="doccomment">/// Parses a string that starts with `name`, returns the suffix parsed in a usual way
</span><span class="kw">fn </span>tag&lt;T&gt;(name: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str, meta: <span class="kw-2">&amp;</span>str, help: <span class="kw">impl </span>Into&lt;Doc&gt;) -&gt; <span class="kw">impl </span>Parser&lt;T&gt;
<span class="kw">where
    </span>T: FromStr,
    &lt;T <span class="kw">as </span>FromStr&gt;::Err: std::fmt::Display,
{
    <span class="comment">// closure inside checks if command line argument starts with a given name
    // and if it is - it accepts it, otherwise it behaves like it never saw it
    // it is possible to parse OsString here and strip the prefix with
    // `os_str_bytes` or a similar crate
    </span>any(<span class="string">""</span>, <span class="kw">move </span>|s: String| <span class="prelude-val">Some</span>(s.strip_prefix(name)<span class="question-mark">?</span>.to_owned()))
        <span class="comment">// this defines custom metavar for the help message
        // so it looks like something it designed to parse
        </span>.metavar(<span class="kw-2">&amp;</span>[(name, Style::Literal), (meta, Style::Metavar)][..])
        .help(help)
        <span class="comment">// this makes it so tag parser tries to read all (unconsumed by earlier parsers)
        // item on a command line instead of trying and failing on the first one
        </span>.anywhere()
        <span class="comment">// At this point parser produces `String` while consumer might expect some other
        // type. [`parse`](Parser::parse) handles that
        </span>.parse(|s| s.parse())
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Output</summary>
<p>Instead of usual metavariable <code>any</code> parsers take something that can represent any value</p>
<div class='bpaf-doc'>
$ app --help<br>
<p><b>Usage</b>: <tt><b>app</b></tt> [<tt><b>bs=</b></tt><tt><i>BLOCK</i></tt>] [<tt><b>count=</b></tt><tt><i>NUM</i></tt>] <tt><b>of=</b></tt><tt><i>FILE</i></tt> [<tt><b>+turbo</b></tt>]</p><p><div>
<b>Available options:</b></div><dl><dt><tt><b>bs=</b></tt><tt><i>BLOCK</i></tt></dt>
<dd>How many bytes to read at once</dd>
<dt></dt>
<dd>[default: 1024]</dd>
<dt><tt><b>count=</b></tt><tt><i>NUM</i></tt></dt>
<dd>How many blocks to read</dd>
<dt><tt><b>of=</b></tt><tt><i>FILE</i></tt></dt>
<dd>Save results into this file</dd>
<dt><tt><b>+turbo</b></tt></dt>
<dd>Engage turbo mode!</dd>
<dt><tt><b>-h</b></tt>, <tt><b>--help</b></tt></dt>
<dd>Prints help information</dd>
</dl>
</p>
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<p>Output file is required in this parser, other values are optional</p>
<div class='bpaf-doc'>
$ app <br>
<b>Error:</b> expected <tt><b>of=</b></tt><tt><i>FILE</i></tt>, pass <tt><b>--help</b></tt> for usage information
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<div class='bpaf-doc'>
$ app of=simple.txt<br>
Options { block_size: 1024, count: 1, output_file: "simple.txt", turbo: false }
</div>
<p>Since options are defined with <code>anywhere</code> - order doesn’t matter</p>
<div class='bpaf-doc'>
$ app bs=10 of=output.rs +turbo<br>
Options { block_size: 10, count: 1, output_file: "output.rs", turbo: true }
</div>
<div class='bpaf-doc'>
$ app +turbo bs=10 of=output.rs<br>
Options { block_size: 10, count: 1, output_file: "output.rs", turbo: true }
</div>
<div class='bpaf-doc'>
$ app bs=65536 count=12 of=hello_world.rs<br>
Options { block_size: 65536, count: 12, output_file: "hello_world.rs", turbo: false }
</div>
</details>
<h2 id="see-also"><a class="doc-anchor" href="#see-also">§</a>See also</h2>
<p><a href="fn.any.html" title="fn bpaf::any"><code>any</code></a> - a generic version of <code>literal</code> that uses function to decide if value is to be parsed
or not.</p>
</div></details></section></div></main></body></html>